## 自定义List接口
```java
/**
 * 线性表接口，和存储结构无关
 */
public interface List {
    //返回表中元素的个数
    int size();

    //返回线性表中序号为i的元素
    Object get(int i);

    //返回线性表是否为空
    boolean isEmpty();

    //返回线性表中是否包含某元素
    boolean contains(Object e);

    //返回某元素e在线性表中的序号
    int indexOf(Object e);

    //把元素e添加到线性表中i号位置
    void add(int i, Object e);

    //把元素e添加到线性表末尾
    void add(Object e);

    //把元素e添加到某元素之前
    boolean addBefore(Object obj, Object e);

    //把元素e添加到某元素之后
    boolean addAfter(Object obj, Object e);

    //删除线性表中序号为i的元素，并返回
    Object remove(int i);

    //删除线性表中第一个与e相同的元素
    boolean remove(Object e);

    //替换线性表中序号为i的数据元素e，返回原数据元素
    Object replace(int i, Object e);
}

```
# 手写顺序表
```java
/**
 * 顺序表，底层采用数组，长度可以动态变化
 * elementData.length表示的是数组开辟空间的长度
 * size表示数组中存放多少个元素
 */
public class ArrayList implements List {

    private Object[] elementData;//底层是一个数组，目前还没有确定长度

    private int size;//元素的个数

    /**
     * 构造方法
     *
     * @param initialCapacity 指定数组的长度
     */
    public ArrayList(int initialCapacity) {
        //给数组分配指定数量的空间
        elementData = new Object[initialCapacity];
        //指定初始化时元素的个数
        size = 0;
    }

    public ArrayList() {
        //给数组分配指定数量的空间
        this(4);
        //指定初始化时元素的个数
        //size = 0;
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public Object get(int i) {
        if (i < 0 || i >= size)
            throw new MyArrayIndexOutOfBoundException("数组索引越界" + i);
//            throw new RuntimeException("数组索引错误"+i);
        else return elementData[i];
    }

    @Override
    public boolean isEmpty() {
        if (size == 0)
            return true;
        else return false;
    }

    @Override
    public boolean contains(Object e) {
        for (int i = 0; i < size; i++) {
            if (elementData[i] == e)
                return true;
        }
        return false;
    }

    @Override
    public int indexOf(Object e) {
        for (int i = 0; i < size; i++) {
            if (elementData[i] == e)
                return i;
        }
        return -1;
    }

    @Override
    public void add(int i, Object e) {
        if (i < 0 || i >= size)
            throw new MyArrayIndexOutOfBoundException("数组索引越界" + i);
        //如果数组满了
        if (size == elementData.length) {
            grow();
        }
        //后移i及其后面的元素，从最后一个元素开始
        for (int j = size; j > i ; j--) {
            elementData[j] = elementData[j-1];
        }
        //给数组中i处赋值
        elementData[i] = e;
        size++;
    }

    @Override
    public void add(Object e) {
        //如果数组满了
        if (size == elementData.length) {
            grow();
        }
        elementData[size] = e;
        size++;
    }

    /**
     * 对数组进行扩容
     */
    private void grow(){
//            //新创建一个新的数组，长度是旧数组的两倍
//            Object[] newArray = new Object[elementData.length*2];
//            //把旧数组中的数据拷贝到新数组中
//            for (int i = 0; i < size; i++) {
//                newArray[i] = elementData[i];
//            }

//            //让elementData指向新数组
//            elementData = newArray;
        //
        elementData = Arrays.copyOf(elementData, elementData.length * 3/2);
    }

    @Override
    public boolean addBefore(Object obj, Object e) {
        int i = this.indexOf(obj);
        if (i != -1){
            this.add(i,e);
            return true;
        }else return false;
    }

    @Override
    public boolean addAfter(Object obj, Object e) {
        int i = this.indexOf(obj);
        if (i != -1){
            this.add(i+1,e);
            return true;
        }
        return false;
    }

    @Override
    public Object remove(int i) {
        if (i < 0 || i >= size)
            throw new MyArrayIndexOutOfBoundException("数组索引越界" + i);
        Object e = elementData[0];
        for (int j = size-1; j > i; j--) {
            elementData[j-1] = elementData[j];
        }
        return e.toString();
    }

    @Override
    public boolean remove(Object e) {
        return false;
    }

    @Override
    public Object replace(int i, Object e) {
        return null;
    }

    @Override
    public String toString() {
        if (size==0){
            return "[]";
        }
        StringBuilder string = new StringBuilder("[");
        for (int i = 0; i < size; i++) {
            if (i!=size-1)
                string.append(elementData[i]+",");
            else string.append(elementData[i]);

        }
        string.append("]");
        return string.toString();
    }
}
```

# 手写链表
```java
package com.mh.LinkList;

import com.mh.List.List;

public class SingleLinkList implements List {

    private Node head = new Node();//头结点，不错黁出数据，为了编程方便

    private int size;//结点的个数

    @Override
    public int size() {
        return size;
    }

    @Override
    public Object get(int i) {
        Node p = head;
        for (int j = 0; j <= i; j++) {
            p = p.getNext();
        }
        return p.getData();
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean contains(Object e) {
        return false;
    }

    @Override
    public int indexOf(Object e) {
        return 0;
    }

    @Override
    public void add(int i, Object e) {
        //找到前一个结点
        Node p = head;
        for (int j = 0; j < i; j++) {
            p = p.getNext();
        }
        //新创建一个结点
        Node newNode = new Node(e);

        //指明新节点的直接后继
        newNode.setNext(p.getNext());
        //指明新节点的直接前驱
        p.setNext(newNode);

        size++;
    }

    @Override
    public void add(Object e) {
        this.add(size,e);
    }

    @Override
    public boolean addBefore(Object obj, Object e) {
        return false;
    }

    @Override
    public boolean addAfter(Object obj, Object e) {
        return false;
    }

    @Override
    public Object remove(int i) {
        return null;
    }

    @Override
    public boolean remove(Object e) {
        return false;
    }

    @Override
    public Object replace(int i, Object e) {
        return null;
    }

    @Override
    public String toString() {
        Node p = head;
        String s = "[";
        for (int i = 0; i < size; i++) {
            p = p.getNext();
            if (i == size-1)
                s = s + p.getData();
            else s = s + p.getData()+",";
        }
        s = s + "]";
        return s;
    }
}

```