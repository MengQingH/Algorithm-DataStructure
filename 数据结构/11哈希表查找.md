# 哈希表
前面查找的共同点是将给定值和关键字值比较来确定位置。效率取决于比较次数。理想的方法是：不需要比较，根据给定值能直接定位记录的存储位置。这样需要再记录的存储位置和该记录的关键字之间建立一种确定的对应关系，使每个记录的关键字和一个存储位置相对应。
## 哈希表的结构和特点
哈希表，也叫散列表。特点是快，非常快。结构由很多种， 最流行、最容易理解的结构就是顺序表+链表。主结构是顺序表，每个顺序表的结点再单独引出一个一个链表
<br><img src=img/哈希表.jpg><br>
java中的HashSet和HashMap底层就是使用的哈希表。

## 添加数据
表中，num表示要添加的数据。x表示要添加的数据的哈希码。y表示添加的地址。
<br><img src=img/哈希表2.jpg><br>
添加过程：
1. 计算哈希码（调用hashCode()，结果是一个int值，整数的哈希码取自身即可）

2. 计算哈希码在表中的存储位置y=k(x)=x%11。x：哈希码  y：在哈希表中的存储位置  k(x)：函数
3. 存入哈希表：
    * 情况1：一次添加成功。对应的地址处为空，此时创建一个新链表并把该节点添加到链表中。
    * 情况2：多次添加成功。出现了冲突，对应的地址不为空，已经有了链表。调用equals()和对应链表结点进行比较，如果到最后都是false，就创建新节点存储数据并添加到链表末尾。
    * 情况3：不添加。出现了冲突，调用equals()方法和链表元素进行比较，结果为true，表明重复，不添加。

结论：
1. 哈希表添加速度快，三步即可，不考虑冲突。
2. 元素唯一。
3. 元素无序。

## 查询和删除
过程和添加的过程相同。

## hashCode equals方法
1. hashCode()方法：计算哈希码，是一个整数，根据哈希码可以计算出数据在哈希表中的存储位置。
2. equals()方法：添加时出现了冲突，需要通过equals进行比较，判断是否相同。

## 如何减少冲突
如果哈希表的空间远大于最后实际存储的个数，则造成了很大的空间浪费；如果小了，则容易造成冲突。在实际情况中，一般需要根据最终记录存储的个数和关键字的分布特点来确定哈希表的大小。
### 装填因子
装填因子=填入表中的元素个数/哈希表的长度。如果装填因子越小，表明表中还有很多的空单元，则添加发生冲突的可能性就越小。如果装填因子越大，则表明发生冲突的可能性就越大，在查找时耗费的时间就越多。

一般在装填因子在0.5左右的时候，哈希表的性能能达到最优。
### 处理冲突的方法
链地址法、开放地址法、再散列法、建立一个公共溢出区。