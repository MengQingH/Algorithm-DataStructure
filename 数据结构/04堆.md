## 优先队列
* 普通队列：先进先出
* 优先队列：出队时选择优先级最高的元素出队

### 优先队列的实现
1. 使用普通数组：入队时直接把元素放在数组末尾，出队的时候选择数组中时间复杂度最高的元素进行出队，耗费O(n)的时间。
2. 使用顺序数组：不断维护数组的有序性，入队的时候选择合适的位置放置元素，出队的时候直接选择队头优先级最高的元素进行出队。
3. 使用堆：堆的入队和出队效率都是O(nlogn)，平均来讲，效率远远高于前面两种方式。
<br><img src=img/优先队列.png>

## 二叉堆
本质上是一种完全二叉树。分为两种类型：最大堆和最小堆
* 最大堆：任意一个父亲节点都大于等于它左右孩子结点的值。
* 最小堆：任意一个父亲节点的值都小于等于它左右孩子结点的值。

二叉树的根节点叫做根顶，最大堆和最小堆的特点决定了在最大堆中堆顶是整个堆中的最大元素，最小堆的堆顶是整个堆中的最小元素。

## 二叉堆的实现
由于二叉堆是一个完全二叉树，所以可以使用二叉树的顺序存储方式来存储二叉堆。从二叉树的根节点开始标号，结点i及结点i的左右结点的位置分别为i、2i、2i+1，最后一个非叶子结点的坐标为size/2。存放到数组从1开始之后的序列中，数组的下标就代表二叉树中该位置上的值。
<br><img src=img/二叉堆实现.png><br>
1. 使用先初始化一个空的最大堆，再向最大堆中添加元素的方式来创建一个最大堆。
2. 传入一个数组，创建一个最大堆并把数组中的内容放在最大堆中。

如果数组从0开始存放元素，那么某个结点的父结点、左右孩子结点的位置分别为：(i-1)/2、2*i+1、2*i+2，最后一个非叶子结点的坐标为(size-1)/2。


## 代码实现
```java

```

## 索引堆
普通堆的局限性：
1. 构建堆的过程中，如果元素是非常复杂的结构，交换这些元素消耗是非常大的。
2. 堆建成后，每个元素的索引发生变化，很难定位到每个元素的位置。

因此引入索引堆的概念。如下图所示，索引堆中的元素是由索引和数据组成的，真正表征堆的数组是索引。交换时只是数组的index值发生变化，而不是数据交换。
<br><img src=img/索引堆.png><br><img src=img/索引堆2.png><br>
构建成二叉堆后，索引堆会变成下面的形式，即数组的索引还是表示原来的元素，index表示索引堆中该位置上的元素的坐标。例如索引堆中的第一个元素的index为10，表示该位置上的数据是数组中索引为10的元素。

为了解决在索引堆中替换一个元素效率底下的问题，在索引堆中引入一个新的数组reverse，该数组表示索引i在堆中的位置。例如替换了索引为4的元素，要查找该元素在index数组中的位置，如果按找原来的方法，就要逐个遍历index数组直到查找到4这个元素，如果添加了一个reverse数组，就可以直接查找reverse[4]来找到4在index数组中的位置。
<br><img src=img/索引堆3.png><br>
其中reverse和indexes的关系：
* indexes[i] = j
* reverse[j] = i
* indexes[reverse[i]] = i
* reverse[indexes[i]] = i