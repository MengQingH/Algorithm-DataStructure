## Union-Find算法
Union-Find，并查集算法，主要是解决图论中的 动态连通性 问题的。

连通性问题介绍：动态连通性可以抽象成给一个图连线。比如一个有10个结点的图，互不相连，分别用0-9标记。
<br><img src=img/图.png><br>

使用Union-Find算法实现这几个API：
```java
class UF{
    //将p和q相连
    public void union(int p, int q);
    //判断p和q是否相连
    public boolean connected(int p, int q);
    //返回图中联通分量的个数
    public int count();
}
```
这里的连通是一种等价关系，具有如下三个性质：
1. 自反性：结点p和q是连通的。
2. 对称性：如果p和q连通，那么q和p也连通。
3. 传递性：如果p和q连通，q和r连通，那么p和r也连通。

例如上面的图，0-9任意两个结点都不连通，调用connected会返回false，连通分量为10个。
调用union(0, 1)，那么0和1被连通，连通分量变为9个。
在调用union(1,2)，此时0，1，2都被连通，调用connected(0,2)也会返回true，连通分量变为8个。

可以使用森林来表示图的连通性，用数组来具体实现这个森林。那么怎么用森林表示连通性呢，可以设定树的每个节点都有一个指针指向其父结点，如果是根节点的话，这个指针指向自己。

比如刚才那幅10个结点的图，一开始的时候没有相互连通，就是这样：
```java
class UF {
    // 记录连通分量
    private int count;
    // 节点 x 的节点是 parent[x]
    private int[] parent;

    /* 构造函数，n 为图的节点总数 */
    public UF(int n) {
        // 一开始互不连通
        this.count = n;
        // 父节点指针初始指向自己
        parent = new int[n];
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }

    /* 其他函数 */
}
```