BST的中序遍历结果时有序的(升序)，也可以修改中序遍历顺序，降序遍历BST中的值，代码如下：
```java
//升序
void traverse(TreeNode root) {
    if (root == null) return;
    traverse(root.left);
    // 中序遍历代码位置
    print(root.val);
    traverse(root.right);
}

//降序
void traverse(TreeNode root) {
    if (root == null) return;
    // 先递归遍历右子树
    traverse(root.right);
    // 中序遍历代码位置
    print(root.val);
    // 后递归遍历左子树
    traverse(root.left);
}
```

### 寻找第K小的元素
LeetCode 230.
最常见的思路就是对二叉搜索树进行中序遍历，升序排序，找出第K个元素。

按照这个思路，可以直接写出代码
```java
int kthSmallest(TreeNode root, int k) {
    // 利用 BST 的中序遍历特性
    traverse(root, k);
    return res;
}

// 记录结果
int res = 0;
// 记录当前元素的排名
int rank = 0;
void traverse(TreeNode root, int k) {
    if (root == null) {
        return;
    }
    
    traverse(root.left, k);
    /* 中序遍历代码位置 */
    rank++;
    if (k == rank) {
        // 找到第 k 小的元素
        res = root.val;
        return;
    }
    /*****************/
    traverse(root.right, k);
}
```

### 把二叉搜索树转换为累加树
LeetCode538 1038.
这个问题没有办法使用二叉树的通用思路，思考每个结点应该做什么。还是应该利用BST的中序遍历特性，降序打印BST结点的值，维护一个累加变量sum，把sum赋值给BST中的每一个结点。