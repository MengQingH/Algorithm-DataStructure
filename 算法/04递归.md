## 递归反转整个链表
```java
ListNode reverse(ListNode head) {
    if (head.next == null) return head;
    ListNode last = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return last;
}
```
**对于递归算法，最重要的是明确递归函数的定义**。上面reverse函数的定义是这样的：
输入一个节点head，将以head为起点的链表反转，并返回反转之后的头结点。

那么明确了函数的定义之后，再来看这个问题，比如反转下面的这个链表：
```
1->2->3->4->5->6->NULL
```
第一次执行reverse(head)后，会在``ListNode last = reverse(head.next);``这里进行递归，不要跳进递归，而是要根据刚才的函数定义，来弄清楚这段代码会产生什么结果：
```
1->  reverse(2->3->4->5->6->NULL)
执行完后：
1->  2<-3<-4<-5<-6   (2指向null)
```
根据函数定义，reverse函数会返回反转之后的头结点，用last变量接收，为值为6的节点。
接下来，就把头结点设置为2节点的next，并将头结点的next设置为null，这样函数就反转过来了。

注意点：
1. 递归函数要有base case，也就是这句：
    ```java
    if (head.next == null) return head;
    ```
2. 当链表递归反转之后，新的头结点是last，之前的head变成了最后一个节点，不要忘记链表的末尾要指向null。