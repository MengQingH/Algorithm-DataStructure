# 排序
排序的分类：
<br><img src=img/排序的分类.jpg><br>
排序的复杂度：
<br><img src=img/复杂度.png>

# 希尔排序
希尔排序是插入排序更高效的改进版本，但是希尔排序是非稳定排序。相比直接插入排序的改进：
1. 直接插入排序低效的地方在于每次只能将数据移动一位，但是数据量较少的时候可以忽略。所以希尔排序把整个序列分割成若干子列。
2. 当数据近乎有序时，直接插入排序的效率极高。所以当子列排序完成，整个序列近乎有序时，使用直接插入排序的效率也是非常的高。
## 基本思想：
1. 将整个待排序的序列分割成为若干个子序列，使得每个子序列的元素相对较少，然后对每个子序列分别进行直接插入排序。一次排序完成后，把增量值减小继续分割子序列进行排序，直到最后增量值变为1，序列中的数据基本有序时，此时对所有记录进行进行依次直接插入排序。

2. 希尔排序的分组指的是将相隔某个“增量”的记录组成一个子序列，实现跳跃式移动，使排序的效率提高。
3. 基本有序：指的是小的关键字在前面，大的关键字在后面，不大不小的在中间。例如｛2,1,3,6,4,7,5,8,9,｝就可以称为基本有序。
## 实现步骤
1. 选择一个增量序列t1,t2,...,tk，其中ti>tj,tk=1
2. 按增量序列个数k，对序列进行k趟排序
3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。
<img src=img/shellsort.png>
## 代码实现
```java
```

# 归并排序
## 基本思想
利用了归并的思想实现的排序方法。对于给定一的一组序列，利用递归和分治技术将数据序列划分成越来越小的半子序列，对这个半子序列进行排序，最后用递归的方式将排好序的半子序列合并成越来越大的有序序列。合并过程如下：<br><img src=img/merge.png>
## 实现步骤
自顶向下的归并排序：
<img src=img/mergesort_ub.png><br>

## 自底向上的归并排序
自底向上的归并排序和自顶向下的归并排序的区别在于前者没有分割数组序列的过程，而是直接相邻的序列两两归并，序列的长度从1开始逐渐增加。<br>
自顶向下的归并排序有一个重要的性质就是在排序的过程中没有通过下标直接获取元素，所以可以对链表进行排序。
<br><img src=img/mergesort_bu.jpg>

## 代码实现
```java
```