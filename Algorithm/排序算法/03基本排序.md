# 排序
排序的分类：
<br><img src=../img/排序的分类.jpg><br>
排序的复杂度：
<br><img src=../img/复杂度.png>

# 测试算法时的时间问题
1. 冒泡排序、直接选择排序不管什么情况，都需要跑完两重循环，所以结果比较稳定；而直接插入排序由于受数据的状况影响比较大，所以结果可能变动较大。
2. 当算法规模扩大两倍时，时间的变化近似为符合时间复杂度；但是当算法规模扩大十倍时，出入较大。原因？？？

# O(n²)排序算法
## 冒泡排序
### 算法步骤
1. 比较相邻的元素，如果第一个比第二个大，就交换这两个数。
2. 向后遍历，对每一对相邻元素都进行交换。
3. 重复前面的步骤。
### 代码实现
```java
```

## 直接选择排序
不管在什么情况下，选择排序都要进行完两重循环，所以时间复杂度都是O(n²)。
### 排序过程
1. 在数据中选择最小的元素与第一个元素交换位置，第一个元素位置正确。
2. 在剩下的元素中继续选择最小的元素，与第二个元素交换位置，第二个元素位置正确。
3. 依次进行。
### 代码实现
```java

```

## 直接插入排序
直接插入排序有一个非常重要的性质就是当元素找到正确的位置后可以提前终止循环。所以可以改进直接插入排序插入的方式来提高效率。<br>
并且当数组是近乎有序的时候，直接插入排序的效率会非常的高，有时甚至会比快速排序还要高。
### 排序过程
1. 默认第一个元素位置正确，之后逐渐向前面添加元素到正确队列中。
2. 把第二个元素添加到正确队列中，比较第二个元素和第一个元素的位置，把第二个元素放到正确的位置。
3. 把第三个元素添加到正确队列中，比较第三个元素和第一第二个元素的大小，放到正确的位置。
4. 依次进行。
### 代码实现
```java
```

