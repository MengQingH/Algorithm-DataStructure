<!--
 * @Author: QingHui Meng
 * @Date: 2021-04-01 13:35:19
-->
## 二分查找总结
最基本的二分查找：
1. 初始化 right = nums.length-1
2. 决定了搜索区间是 [left, right]
3. 决定了 while(left <= right)
4. 决定了 left = mid+1 和 right = mid-1

5. 因为只需要找到一个 target 索引，所以当 nums[mid] == target 时可以立即返回

寻找左侧边界的二分查找：
1. 初始化 right = nums.length
2. 决定了搜索区间是 [left, right)
3. 决定了 while(left < right)
4. 决定了 left = mid+1 和 right = mid

5. 因为要找到 target 的最左索引，所以当nums[mid] == target时要收紧右侧边界以锁定左侧边界

寻找右侧边界的二分查找
1. 初始化 right = nums.length
2. 决定了搜索区间是 [left, right)
3. 决定了 while (left < right)
4. 决定了 left = mid+1 和 right = mid

5. 因为要找到 target 的最右侧索引，所以当 nums[mid] == target 时不要立即返回，而要收紧左侧边界以锁定右侧边界。又因为收紧左侧边界时必须 left = mid + 1，所以最后无论返回 left 还是 right，必须减一



## 二分查找框架
```java
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = (right + left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```
示例：寻找一个数
```java
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意

    while(left <= right) { // 注意
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
        }
    return -1;
}
```
### 为什么while循环的条件时<=而不是<？
因为初始化right的赋值是**nums.length-1**，即最后一个元素的索引，而不是**nums.length**。

两者的区别：**前者相当于两端都闭合区间[left, right]，后者相当于左闭右开区间[left, right)**，因为索引大小为nums.length是越界的。

上面这个算法中使用的是两端都闭合的区间。这个区间就是每次进行搜索的区间，可以称之为**搜索区间**，如果搜索空间为空的时候，应该终止循环。

**while(left <= right)的终止条件是 left > right + 1**，在该算法中应该为left == right+1，写成区间的形式就是 [right + 1, right]，代入数字进去就是[3,2]，可见这时区间为空，while循环的终止是正确的。

**while(left < right)的终止条件是 left == right**，写成区间的形式就是 [right, right]，或者带个具体的数字进去 [2, 2]，这时候搜索区间非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就可能出现错误。

### 左右边界设置
上面的算法中，left = mid+1， right = mid-1，为什么要进行加减1？上面明确了搜索区间的概念，并且本算法中搜索区间都是两端闭合的，即[left, right]。当mid不是要找的target时，就去搜索[left, mid-1] 或者 [mid+1, right]，因为mid已经被搜索过了，应该剔除。


## 寻找左侧边界的二分搜索
普通二分查找的缺陷：如[1,2,2,2,3]，查找2，如果想找左侧或者右侧边界，普通的二分查找算法是无法处理的。寻找左侧边界的二分查找：
```java
int left_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0;
    int right = nums.length; // 注意

    while (left < right) { // 注意
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            right = mid; //注意
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; // 注意
        }
    }
    return left;
}
```
### 为什么用while(left < right)而不是<=
**因为初始化right=nums.length**而不是nums.length-1，**因此每次循环的区间都是[left, right)左闭右开**。

### 为什么不返回-1
[1,2,2,2,3]，对于这个数组，算法会返回1，可以这样解读：**nums中小于target的元素一共有1个**。所以，返回值的取值区间为[0,nums.length]，所以可以添加下面的代码在正确的时候return -1：
```java
while (left < right) {
    //...
}
// target 比所有数都大
if (left == nums.length) return -1;
// 类似之前算法的处理方式
return nums[left] == target ? left : -1;
```
### 为什么left=mid-1，right = mid？
因为我们的搜索区间是[left, right)，左闭右开，所以当nums[mid]被检测后，下一步的搜索区间去掉mid分割成两个区间：即[left, mid),[mid+1, right)

### 为什么能够搜索左侧边界？
if(nums[mid] == target ) right = mid;找到target后没有立即返回，而是继续缩小搜索区间的上界right，在区间[left, mid)中继续搜索，不断向左收缩，达到锁定左侧边界的目的。

## 寻找右侧边界的二分查找
```java
int right_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0, right = nums.length;

    while (left < right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            left = mid + 1; // 注意
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;
        }
    }
    return left - 1; // 注意
}
```
### 为什么返回left-1？
注意nums[mid] == target  left=mid+1  ，所以当while循环结束时，nums[left]一定不等于target了，而且nums[left - 1]可能是target。




## 二分查找的实际应用
Lc875. Lc 1011. 首先思考使用for循环解决问题，观察代码形式：
```java
for (int i = 0; i < n; i++)
    if (isOK(i))
        return answer;
```
如果是，就可以使用二分搜索优化搜索空间：如果要求最小值就是搜索左侧边界的二分，如果要求最大值就用搜索右侧边界的二分。
