<!--
 * @Author: QingHui Meng
 * @Date: 2021-04-10 17:05:57
-->
回溯算法需要思考3个问题：
1. 路径：就是已经做出的选择。
2. 选择列表：当前可以做的选择。
3. 结束条件：到达决策树底层，无法再做选择的条件。

回溯算法的框架：
```
result = [];
def backtrack(路径, 选择列表)
    if(满足结束条件)
        result.add(路径)
        return
    
    for 选择 in 选择列表
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```
核心就是for循环里面的递归，在递归调用之前做选择，在递归调用之后撤销选择。

## 全排列问题
对于n个不重复的数，全排列一共有n!个。对于[1,2,3]三个数的全排列，可以先固定第一位是1，第二位是2，第三位是3，然后可以把第二位变成3，第三位只能是2；然后再变化第一位...可以得出下面的树：
<br><img src=img/回溯树.webp><br>

只要从根节点遍历这棵树，记录路径上的数字，就是所有的排列。这棵树就是回溯算法的**决策树**。之所以叫决策树，是因为每个节点我们都在**做决策**，比如红色节点，可以选择1，也可以选择3，但是不能选择2，因为2在后面，之前已经选择过了，而全排列不允许使用重复数字。

根据这个节点，解释要考虑的三个问题：
1. [2]是 路径，记录已经做过的选择；
2. [1,3]是 选择列表，表示当前可以做出的选择；
3. 结束条件就是遍历到树的底层，在这里就是选择列表为空的时候。

最后可以写出代码：